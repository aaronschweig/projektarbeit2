\documentclass[
	12pt,
	BCOR=5mm,
	DIV=12,
	headinclude=on,
	footinclude=off,
	parskip=half,
	bibliography=totoc,
	listof=entryprefix,
	toc=listof,
	numbers=noenddot,
	plainfootsepline
]{scrreprt}

%	Konfigurationsdatei einziehen
\input{config}

\begin{document}

\TitelDerArbeit{TODO}
\AutorDerArbeit{Aaron Schweig}
\Firma{Hays AG}
\Kurs{WWI18SEC}

\input{titlepage}

\pagenumbering{roman} % Römische Seitennummerierung
\normalfont

%	Kurzfassung
\input{abstract}

%	Inhaltsverzeichnis
\tableofcontents

%	Abbildungsverzeichnis
\listoffigures

%	Tabellenverzeichnis
% \listoftables

% 	Abkürzungsverzeichnis (siehe Datei acronyms.tex!)
\input{acronyms}
\ohead{Acronyms} % Neue Header-Definition

%--------------------------------
% Start des Textteils der Arbeit
%--------------------------------
\clearpage
\ihead{\chaptername~\thechapter}
\ohead{\headmark}
\pagenumbering{arabic}

Outline:
\begin{itemize}
	\item Einleitung schreiben, wieso das Thema wichtig ist und wieso die Schnittstelle so relevant ist
	\begin{itemize}
		\item kurzes Aufzeigen des Problems und Hintergrundes der Arbeit
	\end{itemize}
	\item Kurz die Historie von Microservices erklären
	\begin{itemize}
		\item von Monolithen über SOA bis hin zu Microservices
		\item Anhand eines versimplifizierten beispiels aufzeigen wie Zielarchitekturen aussehen
	\end{itemize}
	\item Def. Microservice, Gouvernance und Observability raushauen
	\begin{itemize}
		\item Dabei auf die verschiedenen Säulen der Observability achten
		\item Wichtigstens Aspekte bei Gouvernance noch einmal herausstellen
		\item Eigentliche Pros der Microservice-Def unter den Gesichtspunkten der G\&O evlt nicht mehr so gut
	\end{itemize}
	\item Wo liegt überhaupt das Problem (nochmal aus Einleitung aufgreifen), Herausarbeiten, evtl. ja schon passiert?
	\item Herausarbeiten von Kriterien für ein Tool im Schnittstellenbereich zwischen G\&O
	\item Wie sehen potenzielle Lösungen unter Berücksichtigung der auf Basis des Problems hergeleiteten Kriterien aus?
	\begin{itemize}
		\item Eine Idee von Elastic vorstellen $\Rightarrow$ APM zusammen mit ML-Nodes können zur Anomaly-Detection und Predicitve Maintance genutzt werden. Lösen die das eigentliche Problem, wenn ja in welchem Ausmaß
		\item Kurze Einführung in Graphdatenbanken, im speziellen Neo4J. Wieso passen die so gut? referenzieren auf Bilder und \enquote{Abhängigkeiten} Wie kann damit eine Lösung konstruiert werden?
		\begin{itemize}
			\item Statischer Ansatz $\Rightarrow$ von den Entwicklern definierte Abhängigkeiten werden in der Service-Definition angegeben. Der Graph kann aus diesen SD's erstellt werden. Hier gibt es Probleme: Manuelle Veranwtortlichkeit widerspricht eigentlicher Idee von Risikoeinschätzung, da ein neuer Fehler Mensch eingebaut wird.
			\item Automatischer Nutzungsbasierter, somit dynamischer Aufbau des Graphen. Prinzip ähnlich wie bei Prometheus (populäres Tool zum sammeln von Metriken). Konzept ähnlich wie Distributed Tracing. Dort werden alle Traces mit ihren Spans zusammengefasst und zentral ausgewertet. Kombination aus dieser Idee mit Prometheus-Ansatz sieht dann folgendermaßen aus:
			
			Jeder Service exposed einen \texttt{/traffic}-Endpoint der unstrukturierte Daten bzgl. der Netzwerkaktivität enthält. Diese können dann in einem Service der für den Aufbau des Graphen zuständig ist zu ebendiesem umgewandelt werden.
			\item Es kann zusätzlich überlegt werden, ob anstatt dieses \texttt{PULL}-Verfahrens eine Push Variante gewählt wird, welche ähnlich wie \texttt{fluentd} als Sidecar in einer Containererisierten Umgebung läuft. Die könnte dann periodisch die Netzwerkdaten pushen, wenn sie Zugriff darauf hat.
		\end{itemize}
		\item Es kann überlegt werden welche Metadaten zusätzlich im Rahmen dieses Graphen eine sinnvolle Ergänzugn bieten würden, sodass ein weiterer Mehrwert geschaffen werden kann. (Ist das noch im Rahmen der Arbeit? Kommt das eher in den Ausbilck mit ein paar Ideen?)
	\end{itemize}
	\item Wie können jetzt die Sachen in dem coolen Graphen genutzt werden?
	\begin{itemize}
		\item Kurze \texttt{CYPHER-QUERIES} Aufschreiben:
		\begin{itemize}
			\item Wie finde ich affectete services raus
			\item was passiert wenn ein Service X ausfällt
			\item Was ist die Zentralste Komponente in meinem Unternehmen
			\item usw.
		\end{itemize}
	\end{itemize}
\end{itemize}

Fragen:
\begin{itemize}
	\item Muss ich erklären was ein Graph ist und wie er funktioniert?
\end{itemize}

\chapter{Einleitung}

\input{chapters/microservice_observability_gouvernance.tex}

\section{Kriterien für gute Gouvernance}

Um im weiteren Verlauf der Arbeit die bereits bestehende und auch die vorgeschlagene Lösung zur Gouvernance und Observability von Microservice miteinander vergleichen zu können müssen einige Kriterien eingeführt werden. Um diese Kriterien zu erarbeiten wird auf vorherige Definition der Gouvernance und Observability geschaut \marginpar{Ref auf G \& O Def.}. Wie bereits zuvor festgestellt wurde besteht die Observability aus drei Säulen - dem \textit{Logging}, dem \textit{Tracing} und den \textit{Metriken}. Ein System welches zum Ziel hat Microservices zu observieren muss also auch in diesem drei Bereichen etwas beitragen. 

Des weiteren spielen Aspekte aus der Microservice Gouvernance eine Rolle für einene Technologie-Stack, welcher wie der hier vorgestellte versucht eine Brücke zwischen diesen beiden Bereichen zu bilden. Ein besonders großer und schwerwiegender Punkt der Microservice Gouvernance stellt eine dezentralisierte Verwaltung dar. Wie bereits \citeauthor{LeanixGouv} in seinem Artikel sagt:
\enquote{
	The main concept of these Microservices are the reusability of assets and tools which can be decentralized. The core theme of a decentralization governance is the concept of building and running it. This decentralized model is best suited for Microservices governances.
}\autocite{LeanixGouv}

Ein Tool welches in diesem Bereich helfen will, muss also als Entscheidungsstütze für dezentralisierte Serviecs funktionieren, um einen mehrwert zu schaffen. \\
Des weiteren muss eine Wertschöpfung aus den gewonnen Daten gezogen werden können. Es stellt also einen wichtigen Faktor dar, alle gesammelten Daten so aufzubereiten, dass es für den Nutzer dieses Tools einen Mehrwert bietet, welcher darüber hinausgeht nur einen Einblick in ebendiese Daten zu erhalten. Beispiele dafür wären Anwendungen im Bereich der \textbf{Predicitve Maintance} oder der \textbf{Anomaly Detection}, usw.

Tools, welche diesen Bereich abdecken müssen also in den folgenden drei großen Kriterien einen Mehrwert gegenüber bestehenden Lösungen bieten:

\begin{enumerate}
	\item Grundelgende Aspekte und Funktionen aus dem Bereich der Microservice Observability müssen abgedeckt sein. Dies beinhaltet die drei Säulen Logging, Tracing und Metriken.
	\item Die dezentralisierte Natur von Microservices muss gefördert werden, sodass ein Tool Entscheidungen - technischer oder unternehmerischer Natur - unterstützen und postiv beeinflussen kann.
	\item Gewonne Daten, egal aus welchen Bereich, müssen einen Mehrwert für den Nutzer darstellen, der über das reine Einsehen der gesammelten Daten hinausgeht.
\end{enumerate}

Auf Basis dieser drei Kriterien sollen nun bestehende Lösungen bewertet werden und mit der eigenen Lösungen verglichen werden, um festzustelle, ob die vorgeschlagene Lösungen
\begin{enumerate}
	\item den definiert Kriterien entspricht und
	\item einen nicht vorhandenen Mehrwert gegenüber bestehenden Lösungen bietet.
\end{enumerate}

Zuletzt ist es sehr wichtig, sollte ein neues Tool gewählt werden darauf zu achten, dass es offenen Standards folgt, um sicherzustelle, dass ein neues (oder bestehendes) System kompatibel ist und mit fremden Tools interagieren kann. Dies ist wichtig, damit auch Unternehmen sicherstellen können, dass der Aufwand, welcher mit der Einführung eines neuen Tolls kommt, ein lohnenswerter ist und eine langfristige Integration aufgrund von Kompatibilität als sinnvoll erachtet werden kann,

\section{Verschiedene Ansätze zum lösen von Gouvernance und Observability}
\subsection{Eigene Ansätze}
\subsection{Ansätze verschiedener Unternehmen}
\begin{itemize}
	\item Elastic \marginpar{Anomaly Detection}
	\item Neo4J \marginpar{ServiceRegistry (Idee für die Arbeit)}
	\item Netflix \marginpar{Master of Microservice}
\end{itemize}
Microservice Gouvernance und Themen der Observability sind bekannte Probleme und wurden schon oft von verschiedenen Organsiationen gelöst. Bewegt man sich im OpenSource bereich so findet sich mit der \ac{CNCF} ein Zusammenschluss, welcher versucht offene Standards für viele elementare Bereiche der Observability und der Gouvernance zu erreichen.

Die \ac{CNCF} definiert sich selbst folgendermaßen:

\enquote{
Cloud native Technologien ermöglichen es Unternehmen, skalierbare Anwendungen in modernen, dynamischen Umgebungen zu implementieren und zu betreiben. Dies können öffentliche, private und Hybrid-Clouds sein. Best-Practises, wie Container, Service-Meshs, Microservices, immutable Infrastruktur und deklarative APIs, unterstützen diesen Ansatz.

Die zugrundeliegenden Techniken ermöglichen die Umsetzung von entkoppelten Systemen, die belastbar, handhabbar und beobachtbar sind. Kombiniert mit einer robusten Automatisierung können Softwareentwickler mit geringem Aufwand flexibel und schnell auf Änderungen reagieren.

Die Cloud Native Computing Foundation fördert die Akzeptanz dieser Paradigmen durch die Ausgestaltung eines Open Source Ökosystems aus herstellerneutralen Projekten. Wir demokratisieren modernste und innovative Softwareentwicklungs-Patterns, um diese Innovationen für alle zugänglich zu machen.
}\autocite{CNCFGithub}

Die \ac{CNCF} vereint also mehrere Tools, welche allen offenen Standards folgen, damit Unternehmen unabhängig von großen Cloudanbietern wie \ac{GCP}, \ac{AWS} oder Microsoft Azure eine Cloud-Infrastruktur aufbauen können. Ein paar Beispiele der \ac{CNCF} zugehörigen Projekte sind treibende, grundlegende Softwarelösungen wie Kubernetes oder OpenShift.

Zusätzlich dient die \ac{CNCF} selbst auch als Organsiation, um verschiedene Industriestandards duchzusetzen. So wurde beispielsweise mithilfe der \textbf{Open Telemetry} ein Standard geschaffen, welcher Toolübergreifen das Sammeln und Auswerten verscheidener Tracingdaten ermöglicht. Dies ermöglicht einem Unternehmen, einen eigenen Stack zusammenzustellen, da es sich darauf verlassen kann, dass die Projekte, welche Teil der \ac{CNCF} sind miteinander kommunizieren und arbeiten können.

\url{https://landscape.cncf.io/category=coordination-service-discovery,service-proxy,service-mesh,observability-and-analysis&format=card-mode}

\section{Auf Basis der kriterien hergeleiteter eigener Ansatz mithilfe eines MicroserviceGraphen}

Innerhalb der Softwareentwicklung stellen sich die oben beschriebenen Probleme oftmals in ähnlicher Form dar. Ein praktisches Beispiel kommt aus dem Bereich der Webentiwcklung, in welchem Bundler ein ähnliches Problem zu bekämpfen haben. Diese besitzen zur Aufgabe Code, welcher in verschiedenen Dateien verteilt ist so zusammenzuführen, das später eine einzige syntaktisch korrete und ausführbare Datei vorliegt. Dabei muss allerdings bedacht werden, dass verschiedene Dateien unterschiedliche Codesegmente aus anderen Dateien importieren können und wiederum eigene Funktionen oder Variablen exportieren können. Dabei zählt es zu den Aufgaben eines Bundlers sicherzustellen, dass ein für die Programmiersprace valider Kontrollflow entsteht. Um dieses Problem zu lösen nutzen Bundler die Möglichkeit, einen Dependency-Graphen auf Basis der Imports und Exports aufzustellen. Dieser wird dann genutzt, um anhand des Startpunktes des Graphen die Zusammenführung der Dateien zu beginnen. Dabei müssen zusätzlich noch weitere Problem gelöst werden, da innerhaln eines Graphen auch circuläre Abhängigkeiten entstehen können, welche aufgelöst werden müssen. Ein Beispiel einer Zirkulären Abhängigkeit kann der \autoref{fig:GraphViz} entnommen werden.

\begin{itemize}
	\item Man es während CI/CD Stuff machen. Auch part von Microservices.
	\item Man kann es danach dynamisch nach Usage discovern lassen.
	\item Man kann einen kombinierten Ansatz wählen, um sowohl initial den Service inklusikve Metadaten sehen und danach die Nutzung ähnlich wie im Epsagon Dashboard zu sehen
\end{itemize}

\begin{figure}[h]
	\centering
	\makebox[\textwidth]{\includegraphics[width=\linewidth]{img/dependency-graph.png}}
	\caption[Dependency Graph]{Visulaisierung eines Dependency-Graphen mit zirkulären Abhängigkeiten. Quelle: \cite[]{GraphViz}}
	\label{fig:GraphViz}
\end{figure}
 All diese Elemente dienen als Grundlage zu der Idee, dass zur Risikoeinschätzung der Auswirkungen eines Fehelerfalls innerhalb einer Microservicearchitektur ein ähnlicher Dependency-Graph eine große Hilfe darstellen würde. Baut man den Graphen so auf, wie in obiger Analogie beschrieben, so erhält man einen Graphen, welcher Anzeigt ob und wie weit bestimmte Microservices miteinenander kommunizieren oder sogar voneinander Abhängigkeit sind. Dies beitet die Möglichkeit wertvolle Einblicke in das \textit{makroskopische} Zusammenspiel der einzelnen Komponenten einer Architektur zu erhalten. Ein Softwarearchitekt hat nun die Möglichkeit bei der Entscheidung über die Einführung eines neuen Service Informationen aus ebendiesem Graphen zu nutzen, um festzustellen ob eine zu Starke Abhängikteit zwischen Services vorhanden ist, oder ob es bei der Entwicklung bereits bestehende Abhängigkeiten gibt.
\marginpar{Hier eventuell bissjen über Kopplung auf Codebassis labern wie das Auswirkungen auf Arhcitektur haben kann} 
Der beschriebene Graph kann also als eine Art Service-Registry angesehen werden, welche Informationen zu der Beziehung zwischen verschiedenen Services beinhaltet. Gleichzeitig wird dadurch vor allem der Bereich der Microservice-Gouvernance betreten, wo eine Service-Registry eine zentrale Komponente darstellt. 

Zusammenfassend lässt sich das Konzept also folgendermaßen beschreiben: \\
Eine Schnittstelle zwischen Microservice-Gouvernance und -Observability wird mithilfe eines Dependency-Graphen gebildet. So spielen Aspekte einer Service-Registry und Elemente des Distributed-Tracing eine große Rolle in diesem Ansatz. 
\chapter{Idee und POC eines Microservice-Dependency Graphen}

Nun, da Grundlegende Begriffe geklärt wurden, werden Kriterien heruasgeabreitet, welche zur spätere Einschätzung und Bewertung eines vorgeschlagenen Ansatzes diesen sollen. Gleichzeitig werden diese Kriterien genutzt, um beretis bestehende Ansätze zu untersuchen und auf ihre Anwendbarkeit zu überprüfen.

Im Rahmen der Observability stehen drei große Säulen im Fokus:
\begin{enumerate}
	\item Logging
	\item Tracing
	\item Metriken
\end{enumerate}

Diese drei Elemente spielen eine wichtige Rolle um eine Lösung im Bereich der Observability liefern zu können. Im Rahmen dieser Arbeit wird vor allem ein Augenmerk auf den Status einer Microservice-Archtitektur gelegt, welche nicht zum Ziel hat, die softwaretechnische Ursache des Problems zu finden, sondern den Service oder den Container zu identifizieren, welcber für den Ausfall veranwtortlich ist. Gleichzeitig gibt es die Anforderung, dass die Abhängigkeiten verschiedener Microservices voneinander dargestellt und in Form von nutzbaren, auswertbaren Daten vorliegen. Hierbei kommt allerdings ein Punkt der Observability zu tragen, da dies, wie später näher erläutert wird auch mithilfe von Tracing erreicht werden kann.\\
Außerdem muss es möglich sein, die gewonnen Daten nutzbar zu machen, um nicht nur feststellen zu können, wecher Service die Ursache des Problems ist, sonder auch, um die Auswirkungen auf andere Services feststellen zu können. Es muss also ein einfacher Weg geschaffen werden, damit die Auswirkungen eines Fehlers schnell festgestellt werden können. 

\chapter{Bewertung und Einschätzung der Arbeit, sowie Ausbilck auf künfitge Arbeiten}
%	Literaturverzeichnis
\clearpage
\ihead{}
\printbibliography[title=Literaturverzeichnis]
\cleardoublepage

% Der Anhang beginnt hier - jedes Kapitel wird alphabetisch aufgezählt. (Anhang A, B usw.)
% \appendix
% \ihead{\appendixname~\thechapter} % Neue Header-Definition

% Ehrenwörtliche Erklärung ewerkl.tex einziehen
\input{ewerkl.tex}


\end{document}
