\documentclass[
	12pt,
	BCOR=5mm,
	DIV=12,
	headinclude=on,
	footinclude=off,
	parskip=half,
	bibliography=totoc,
	listof=entryprefix,
	toc=listof,
	numbers=noenddot,
	plainfootsepline
]{scrreprt}

%	Konfigurationsdatei einziehen
\input{config}

\begin{document}

\TitelDerArbeit{TODO}
\AutorDerArbeit{Aaron Schweig}
\Firma{Hays AG}
\Kurs{WWI18SEC}

\input{titlepage}

\pagenumbering{roman} % Römische Seitennummerierung
\normalfont

%	Kurzfassung
\input{abstract}

%	Inhaltsverzeichnis
\tableofcontents

%	Abbildungsverzeichnis
\listoffigures

%	Tabellenverzeichnis
\listoftables

% 	Abkürzungsverzeichnis (siehe Datei acronyms.tex!)
\input{acronyms}
\ohead{Acronyms} % Neue Header-Definition

%--------------------------------
% Start des Textteils der Arbeit
%--------------------------------
\clearpage
\ihead{\chaptername~\thechapter}
\ohead{\headmark}
\pagenumbering{arabic}

\chapter{Einleitung}
\chapter{Microservice und SOA}
\section{Entwicklung in den letzten Jahren}
\section{Probleme und Herausforderungen im Bereich Gouvernance und Observability}
\begin{itemize}
	\item Abgrenzung von Microservices gegenüber API's \\
	Wenn von Microserice Gouvernance und Observability geredet wird, ist oftmals die unterleigende Architektur mit Fokus auf VM-Daten usw gemeint. Wird von APIS gesprchen hat es oftmals mit business logik undso zutun
\end{itemize}
\begin{itemize}
	\item Welcher bereich soll observiert werden?
	\begin{itemize}
		\item Soll es um die hardware Daten (Memory, CPU, klassische cloud metriken) gehen oder um
		\item Softwareinformationen bzgl. software logging und tracing
	\end{itemize}
\end{itemize}
\section{Kriterien für gute Gouvernance}
\section{Verschiedene Ansätze zum lösen von Gouvernance und Observability}
\subsection{Eigene Ansätze}
\subsection{Ansätze verschiedener Unternehmen}
\begin{itemize}
	\item Elastic
	\item Neo4J
	\item Netflix
\end{itemize}
Microserice Gouvernance und Themen der Observability sind bekannte Probleme und wurden schon oft von verschiedenen Organsiationen gelöst. Bewegt man sich im OpenSource bereich so findet sich mit der \ac{CNCF} ein Zusammenschluss, welcher versucht offene Standards für viele elementare Bereiche der Observability und der Gouvernance zu erreichen.

Die \ac{CNCF} definiert sich selbst folgendermaßen:

\enquote{Cloud native Technologien ermöglichen es Unternehmen, skalierbare Anwendungen in modernen, dynamischen Umgebungen zu implementieren und zu betreiben. Dies können öffentliche, private und Hybrid-Clouds sein. Best-Practises, wie Container, Service-Meshs, Microservices, immutable Infrastruktur und deklarative APIs, unterstützen diesen Ansatz.

Die zugrundeliegenden Techniken ermöglichen die Umsetzung von entkoppelten Systemen, die belastbar, handhabbar und beobachtbar sind. Kombiniert mit einer robusten Automatisierung können Softwareentwickler mit geringem Aufwand flexibel und schnell auf Änderungen reagieren.

Die Cloud Native Computing Foundation fördert die Akzeptanz dieser Paradigmen durch die Ausgestaltung eines Open Source Ökosystems aus herstellerneutralen Projekten. Wir demokratisieren modernste und innovative Softwareentwicklungs-Patterns, um diese Innovationen für alle zugänglich zu machen.}\autocite{CNCFGithub}

\section{Auf Basis der kriterien hergeleiteter eigener Ansatz mithilfe eines MicroserviceGraphen}

Innerhalb der Softwareentwicklung stellen sich die oben beschriebenen Probleme oftmals in ähnlicher Form dar. Ein praktisches Beispiel kommt aus dem Bereich der Webentiwcklung, in welchem Bundler ein ähnliches Problem zu bekämpfen haben. Diese besitzen zur Aufgabe Code, welcher in verschiedenen Dateien verteilt ist so zusammenzuführen, das später eine einzige syntaktisch korrete und ausführbare Datei vorliegt. Dabei muss allerdings bedacht werden, dass verschiedene Dateien unterschiedliche Codesegmente aus anderen Dateien importieren können und wiederum eigene Funktionen oder Variablen exportieren können. Dabei zählt es zu den Aufgaben eines Bundlers sicherzustellen, dass ein für die Programmiersprace valider Kontrollflow entsteht. Um dieses Problem zu lösen nutzen Bundler die Möglichkeit, einen Dependency-Graphen auf Basis der Imports und Exports aufzustellen. Dieser wird dann genutzt, um anhand des Startpunktes des Graphen die Zusammenführung der Dateien zu beginnen. Dabei müssen zusätzlich noch weitere Problem gelöst werden, da innerhaln eines Graphen auch circuläre Abhängigkeiten entstehen können, welche aufgelöst werden müssen. Ein Beispiel einer Zirkulären Abhängigkeit kann der Folgenden Grafik entnommen werden: \textbf{GRAFIK CIRCULAR}. All diese Elemente dienen als Grundlage zu der Idee, dass zur Risikoeinschätzung der Auswirkungen eines Fehelerfalls innerhalb einer Microsericearchitektur ein ähnlicher Dependency-Graph eine große Hilfe darstellen würde. Baut man den Graphen so auf, wie in obiger Analogie beschrieben, so erhält man einen Graphen, welcher Anzeigt ob und wie weit bestimmte Microservices miteinenander kommunizieren oder sogar voneinander Abhängigkeit sind. Dies beitet die Möglichkeit wertvolle Einblicke in das \textit{makroskopische} Zusammenspiel der einzelnen Komponenten einer Architektur zu erhalten. Ein Softwarearchitekt hat nun die Möglichkeit bei der Entscheidung über die Einführung eines neuen Service Informationen aus ebendiesem Graphen zu nutzen, um festzustellen ob eine zu Starke Abhängikteit zwischen Services vorhanden ist, oder ob es bei der Entwicklung bereits bestehende Abhängigkeiten gibt.
\marginpar{Hier eventeuell bissjen über Kopplung auf Codebassis labern wie das Auswirkungen auf Arhcitektur haben kann} 
Der beschriebene Graph kann also als eine Art Service-Registry angesehen werden, welche Informationen zu der Beziehung zwischen verschiedenen Services beinhaltet. Gleichzeitig wird dadurch vor allem der Bereich der Microservice-Gouvernance betreten, wo eine Service-Registry eine zentrale Komponente darstellt. 

Zusammenfassend lässt sich das Konzept also folgendermaßen beschreiben: \\
Eine Schnittstelle zwischen Microserice-Gouvernance und -Observability wird mithilfe eines Dependency-Graphen gebildet. So spielen Aspekte einer Service-Registry und Elemente des Distributed-Tracing eine große Rolle in diesem Ansatz. 
\chapter{Idee und POC eines Microservice-Dependency Graphen}

Nun, da Grundlegende Begriffe geklärt wurden, werden Kriterien heruasgeabreitet, welche zur spätere Einschätzung und Bewertung eines vorgeschlagenen Ansatzes diesen sollen. Gleichzeitig werden diese Kriterien genutzt, um beretis bestehende Ansätze zu untersuchen und auf ihre Anwendbarkeit zu überprüfen.

Im Rahmen der Observability stehen drei große Säulen im Fokus:
\begin{enumerate}
	\item Logging
	\item Tracing
	\item Metriken
\end{enumerate}

Diese drei Elemente spielen eine wichtige Rolle um eine Lösung im Bereich der Observability liefern zu können. Im Rahmen dieser Arbeit wird vor allem ein Augenmerk auf den Status einer Microserice-Archtitektur gelegt, welche nicht zum Ziel hat, die softwaretechnische Ursache des Problems zu finden, sondern den Service oder den Container zu identifizieren, welcber für den Ausfall veranwtortlich ist. Gleichzeitig gibt es die Anforderung, dass die Abhängigkeiten verschiedener Microservices voneinander dargestellt und in Form von nutzbaren, auswertbaren Daten vorliegen. Hierbei kommt allerdings ein Punkt der Observability zu tragen, da dies, wie später näher erläutert wird auch mithilfe von Tracing erreicht werden kann.\\
Außerdem muss es möglich sein, die gewonnen Daten nutzbar zu machen, um nicht nur feststellen zu können, wecher Service die Ursache des Problems ist, sonder auch, um die Auswirkungen auf andere Services feststellen zu können. Es muss also ein einfacher Weg geschaffen werden, damit die Auswirkungen eines Fehlers schnell festgestellt werden können. 

\chapter{Bewertung und Einschätzung der Arbeit, sowie Ausbilck auf künfitge Arbeiten}
%	Literaturverzeichnis
\clearpage
\ihead{}
\printbibliography[title=Literaturverzeichnis]
\cleardoublepage

% Der Anhang beginnt hier - jedes Kapitel wird alphabetisch aufgezählt. (Anhang A, B usw.)
% \appendix
% \ihead{\appendixname~\thechapter} % Neue Header-Definition

% Ehrenwörtliche Erklärung ewerkl.tex einziehen
\input{ewerkl.tex}


\end{document}
