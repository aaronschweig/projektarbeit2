\documentclass[
	12pt,
	BCOR=5mm,
	DIV=12,
	headinclude=on,
	footinclude=off,
	parskip=half,
	bibliography=totoc,
	listof=entryprefix,
	toc=listof,
	numbers=noenddot,
	plainfootsepline
]{scrreprt}

%	Konfigurationsdatei einziehen
\input{config}

\begin{document}

\TitelDerArbeit{TODO}
\AutorDerArbeit{Aaron Schweig}
\Firma{Hays AG}
\Kurs{WWI18SEC}

\input{titlepage}

\pagenumbering{roman} % Römische Seitennummerierung
\normalfont

%	Kurzfassung
\input{abstract}

%	Inhaltsverzeichnis
\tableofcontents

%	Abbildungsverzeichnis
\listoffigures

%	Tabellenverzeichnis
% \listoftables

% 	Abkürzungsverzeichnis (siehe Datei acronyms.tex!)
\input{acronyms}
\ohead{Acronyms} % Neue Header-Definition

%--------------------------------
% Start des Textteils der Arbeit
%--------------------------------
\clearpage
\ihead{\chaptername~\thechapter}
\ohead{\headmark}
\pagenumbering{arabic}


\chapter{Einleitung}
Outline:
\begin{itemize}
	\item Einleitung schreiben, wieso das Thema wichtig ist und wieso die Schnittstelle so relevant ist
	\begin{itemize}
		\item kurzes Aufzeigen des Problems und Hintergrundes der Arbeit
	\end{itemize}
	\item Kurz die Historie von Microservices erklären
	\begin{itemize}
		\item von Monolithen über SOA bis hin zu Microservices
		\item Anhand eines versimplifizierten beispiels aufzeigen wie Zielarchitekturen aussehen
	\end{itemize}
	\item Def. Microservice, Governance und Observability raushauen
	\item Wie sehen potenzielle Lösungen unter Berücksichtigung der auf Basis des Problems hergeleiteten Kriterien aus?
\end{itemize}

% CHAPTER: Microservice - Observability - Governance
\input{chapters/microservice_observability_gouvernance.tex}

\section{Eine Lücke zwischen Governance und Observability}

Im vorherigen Abschnitt wurden einige potenzielle Problempunkte beim Nutzen einer Microservicearchitektur identifiziert. Es sticht vor allem heraus, dass es für einen Verantwortlichen nur sehr schwer möglich ist fundierte Risikoeinschätzungen abzugeben. Es stellt sich im unternehmerischen Alltag oftmals die Frage, wer einen Fehler im System beheben muss. Diese Frage kann genau dann beantwortet werden, wenn klar ist wo der Fehler liegt. Im Abschnitt über Observability sind mithilfe der drei Säulen Möglichkeiten geschaffen einen fehlerhaften Service zu finden. Trotzdem kann auch mithilfe dieser Informationen nicht unbedingt immer die Ursache des Fehlers ausfindig gemacht werden. Ein sehr häufiges Ergebnis bei der Fehleranalyse im Kontext verteilter Systeme ist, dass mehr als ein Service als Fehlerursache in Frage kommt. Das bedeutet, dass der zuständige Mitarbeiter für die Fehleridentifizierung mit mehreren Teams in Kontakt treten muss und diese dann den Fehler in ihren Services so schnell wie möglich beheben können. \\
Auch und vor allem bei Fehlern in einer Software als Kernbestandteil eines Unternehmens greift eine altbekannte Redensart: \textit{Zeit ist Geld}. Dass Zeit wirklich Geld bedeuetet und die Zeit, die bis zum beheben eines Fehlers vergeht so kurz wie möglich gehalten werden muss zeigen Zahlen eines Ausfalls der Amazon Website aus dem Jahr 2016. Dort führte eine Nichterreichbarkeit der Website für nur 20 Minuten zu einem Verlust von ca 3.5 Mio Euro \marginpar{QUELLE}.

An dieser Stelle, einer Schnittstelle zwischen Governance und Observability gilt es so wenig Zeit wie möglich zu verschwenden, um mehr Zeit bei der eigentlichen Fehlerbehebung zur Verfügung zu haben. Es sollte also innerhalb eines Unternehmens eine Möglichkeit geben diese Informationen schnell aufzufinden. Im folgenden werdene einige Anforderungen herausgestellt, welches ein Tools haben muss, um in diesem Schnittstellenbereich einen positiven Einfluss auf die Fehlerbehebung zu haben.

% \section{Verschiedene Ansätze zum lösen von Governance und Observability}
% \subsection{Ansätze verschiedener Unternehmen}
% \begin{itemize}
% 	\item Elastic
% 	\item Neo4j
% \end{itemize}
% Microservice Governance und Themen der Observability sind bekannte Probleme und wurden schon oft von verschiedenen Organsiationen gelöst. Bewegt man sich im OpenSource bereich so findet sich mit der \ac{CNCF} ein Zusammenschluss, welcher versucht offene Standards für viele elementare Bereiche der Observability und der Governance zu erreichen.

% \section{Auf Basis der kriterien hergeleiteter eigener Ansatz mithilfe eines MicroserviceGraphen}

% Innerhalb der Softwareentwicklung stellen sich die oben beschriebenen Probleme oftmals in ähnlicher Form dar. Ein praktisches Beispiel kommt aus dem Bereich der Webentiwcklung, in welchem Bundler ein ähnliches Problem zu bekämpfen haben. Diese besitzen zur Aufgabe Code, welcher in verschiedenen Dateien verteilt ist so zusammenzuführen, das später eine einzige syntaktisch korrete und ausführbare Datei vorliegt. Dabei muss allerdings bedacht werden, dass verschiedene Dateien unterschiedliche Codesegmente aus anderen Dateien importieren können und wiederum eigene Funktionen oder Variablen exportieren können. Dabei zählt es zu den Aufgaben eines Bundlers sicherzustellen, dass ein für die Programmiersprache valider Kontrollflow entsteht. Um dieses Problem zu lösen nutzen Bundler die Möglichkeit, einen Dependency-Graphen auf Basis der Imports und Exports aufzustellen. Dieser wird dann genutzt, um anhand des Startpunktes des Graphen die Zusammenführung der Dateien zu beginnen. Dabei müssen zusätzlich noch weitere Problem gelöst werden, da innerhaln eines Graphen auch circuläre Abhängigkeiten entstehen können, welche aufgelöst werden müssen. Ein Beispiel einer Zirkulären Abhängigkeit kann der \autoref{fig:GraphViz} entnommen werden.

% \begin{itemize}
% 	\item Man es während CI/CD Stuff machen. Auch part von Microservices.
% 	\item Man kann es danach dynamisch nach Usage discovern lassen.
% 	\item Man kann einen kombinierten Ansatz wählen, um sowohl initial den Service inklusikve Metadaten sehen und danach die Nutzung ähnlich wie im Epsagon Dashboard zu sehen
% \end{itemize}

% \begin{figure}[h]
% 	\centering
% 	\makebox[\textwidth]{\includegraphics[width=\linewidth]{img/dependency-graph.png}}
% 	\caption[Dependency Graph]{Visualisierung eines Dependency-Graphen mit zirkulären Abhängigkeiten. Quelle: \cite[]{GraphViz}}
% 	\label{fig:GraphViz}
% \end{figure}
%  All diese Elemente dienen als Grundlage zu der Idee, dass zur Risikoeinschätzung der Auswirkungen eines Fehelerfalls innerhalb einer Microservicearchitektur ein ähnlicher Dependency-Graph eine große Hilfe darstellen würde. Baut man den Graphen so auf, wie in obiger Analogie beschrieben, so erhält man einen Graphen, welcher Anzeigt ob und wie weit bestimmte Microservices miteinenander kommunizieren oder sogar voneinander Abhängigkeit sind. Dies beitet die Möglichkeit wertvolle Einblicke in das \textit{makroskopische} Zusammenspiel der einzelnen Komponenten einer Architektur zu erhalten. Ein Softwarearchitekt hat nun die Möglichkeit bei der Entscheidung über die Einführung eines neuen Service Informationen aus ebendiesem Graphen zu nutzen, um festzustellen ob eine zu Starke Abhängikteit zwischen Services vorhanden ist, oder ob es bei der Entwicklung bereits bestehende Abhängigkeiten gibt.
% Der beschriebene Graph kann also als eine Art Service-Registry angesehen werden, welche Informationen zu der Beziehung zwischen verschiedenen Services beinhaltet. Gleichzeitig wird dadurch vor allem der Bereich der Microservice-Governance betreten, wo eine Service-Registry eine zentrale Komponente darstellt. 

% Zusammenfassend lässt sich das Konzept also folgendermaßen beschreiben: \\
% Eine Schnittstelle zwischen Microservice-Governance und -Observability wird mithilfe eines Dependency-Graphen gebildet. So spielen Aspekte einer Service-Registry und Elemente des Distributed-Tracing eine große Rolle in diesem Ansatz.

\chapter{Konzeption einer graphbasierten Serviceregistry}

Im folgenden Kapitel wird versucht auf Basis der in \vref{chap:Anforderungen} beschriebenen Anforderungen ein Konzept für ein Tool zu erarbeiten, welches als \enquote{intelligente} Service-Registry fungiert. Dazu wird zunächst die eine mögliche Technologiewahl erläutert. Danach werden noch einige möglichen Funktionenen mithilfe von Beispielen vorgestellt.

\section{Wieso wird ein Graph verwendet?}

Das Fundament des vorgeschlagenen Konzept bildet die Abbildung der Services und deren Zusammenhänge in einem Graphen. Ähnlich, wie Microservices danach bestrebt sind, die bestmögliche Technologie für die Anforderung zu wählen, muss auch für ein neues Tool, eine passende Technologie gefunden werden. Um zu verstehen, wieso eine graphbasierte Darstellung für den Anwedungfall gut geeignet ist, soll ein Graph und Graphdatenbanken definiert werden.

\begin{definition}[gerichteter Graph]\autocite[Kapitel 1.2]{Bang-Jensen2007}
	Ein gerichteter Graph ist ein geordnetes Tupel $$G = (V,A)$$ für das gilt:
	\begin{itemize}
		\item $V(G)$ ist eine nichtleere Menge, deren Elemente man Knoten (engl. \textit{verticies}) nennt
		\item und einer endlichen Menge $A(G) \subseteq V \times V$ von geoordneten Tupeln verschiedener Knoten, die man Kanten (engl. \textit{arcs}) nennt.
	\end{itemize}

	Bei einem gerichteten Graphen handelt es sich um ein \textbf{geordnetes Tupel} $v \in A$, wobei die \enquote{Richtung} vorgegeben ist durch die Reihenfolge im Tupel. Bei einem ungerichtetetn Graphen besteht $A$ aus einer Menge \textbf{ungeordneter Tupel}.
\end{definition}

Diese mathematische Definition beschreibt eine interessante Datenstruktur für die Informatik und die Softwareentwicklung. Diese Datenstruktur versucht also die vorgegebenen Eigenschaften eines Graphen wie in der graphentheorie Beschrieben zu realisieren. \\
Eine Unterkategorie bei den gerichteten Graphen sind sowohl zyklische, als auch azyklische gerichtete Graphen. Dabei handelt es sich um Repräsentaten eines gerichteten Graphen, welche keinen gerichteten Kreis enthalten. Betrachtet man nun den Anwedungsfall des zu konzeptionierenden Tools, so stellt man fest, dass ein azyklischer Graph nicht die richtige Wahl wäre. Dies sollim foglenden erläutert werden.

\begin{example}
	Beginnen wir mit der formalen Defitionen des Graphen, welcher die Beziehung zwischen Microservices abbilden soll. Der Graph $G$ besteht dann also aus: 
	\begin{itemize}
		\item der Menge $V(G)=\text{Menge aller Services in einem Unternehmen}$
		\item der Menge $A(G)=\{a,b \mid \text{a benötigt Informationen aus b}\}$
	\end{itemize}
	Der Graph beinhaltet also Informationen über einen Service, als auch über seine Verbindungen mit anderen Services. Da es ein gerichteter Graph ist gilt für $$(a,b), (b,a) \in A(G),\text{ dass }(a,b) \neq (b,a),$$ da es sich bei den Elementen von $A(G)$ um geordnete Tupel handelt. Diese Tatsache spiegelt sich auch in der Relatiät wieder da die Abhängigkeit eines Services $a$ von einem Service $b$ nicht dieselbe Anfrage wiederspiegelt, die Service $b$ von Service $a$ hat.
\end{example}\label{exp:microserviceGraph}

Man erkennt also bereits jetzt, dass rein mit dem mathematischen Modell eines Graphen bereits viele realen Aspekte übereinstimmen, was es als potenzielles Datenmodell qualifiziert. Die Datenstruktur eines Graphen hat zusätzlich noch die Möglichkeit Informationen sowohl an den Knoten, als auch an den Kanten zu speichern \footnote{TODO: Quelle}. Zusätzlich könnte eine weitere Idee aus der \textbf{Graphentheorie} eine nützliche Ergänzung zu der bisherigen Idee darstellen.

\begin{definition}[Fluss]
	In der Graphentheorie stellt ein Fluss eine Funktion $f: A \rightarrow \mathbb{R_+}$ dar, die jeder Kante $a \in A(G)$ einen nichtnegativen Flusswert $f(a) \in \mathbb{R_+}$ zuweist. Des weiteren muss folgende Bedingung erfüllt sein, damit es sich bei dieser Funktion um einen Fluss handelt. Dafür muss gelten, dass der Flusswert einer Kante $a \in A(G)$ höchstens so groß ist, wie die Kapazität der Kante mit: \footnote{TODO: Quelle, Netzwerk noch erklären} $$\forall a \in A(G): f(a) \leq u(a)$$
\end{definition}

Mithilfe der Idee einer Flussfunktion in einem Graphen können die Kanten und die Beziehungen zwischen den einzelnen Services genauer dargestellt werden. Die Gewichtung der Kanten kann eine Repräsentation der Intensität der Nutzung dieser Kante darstellen.

Dieses mathematische Model beschreibt das zu lösende Problem bereis sehr gut. Deshalb ist es sinnvoll als Datenstruktur zur Abbildung der Daten einen Graphen zu wählen. Graphen können auf technischer Ebene auf verschiedenste Weise implementiert werden. Die Entscheidung welcher Implementierung am sinnvollsten ist, soll aber im Rahmen dieser Arbeit nicht getroffen werden. Einer der populärsten Datenbanken im Bereich der Graphdatenbanken stellt Neo4j dar. Diese Datenbank folgt dem Prinzip der \enquote{index-free adjencency}, was soviel bedeutet, wie dass benachbarte Knoten auch nebeneinander persistiert werden, sodass bei einem Lesevorgang auf das kostpieliege Auswerten von Indices verzichtet werden kann. So können auch große Graphen von einer sehr schnellen Lesezeit profitieren. Gleichzeitig bietet kann dieses \ac{DBMS} mithilfe der populären Abfragesprache \texttt{CYPHER} genutzt werden.

\section{Bewertung einer alternativen Methode}

Im folgenden Abschnitt wird eine Methode vorgestellt, welche versucht das gleiche Problem zu lösen, wie das in der Arbeit präsentierte Konzept. Dabei wird versucht verschiedene Komponenten der Firma Elastic zu kombinieren, um eine Lösung zu konstruieren. Elastic ist unter anderem bekannt durch das Produkt ElasticSearch, welches ein dokumentenbasiertes \ac{DBMS} ist.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\linewidth]{img/statista_db.png}
	\caption{Stack Overflow. "Most wanted database skills among software developers worldwide as of early 2020." Chart. February 15, 2020. Statista. Accessed August 18, 2020. \url{https://www.statista.com/statistics/793854/worldwide-developer-survey-most-wanted-database/}}
\end{figure}

ElasticSearch erreicht eine sehr gute Suchperformance durch das verwenden von Indizes und einer guten Tokenisation der indizierten Daten. Zusätzlich ist ElasticSearch so aufgebaut, dass es einfach innerhalb eines Clusters verwendet werden kann. Die in einem Cluster vorhandenen Nodes können auf verscheidenste Weisen konfiguriert werden. Innerhalb von ElasticSearch gibt es auch die Möglichkeit \ac{ML} Funktionen zu verwenden. Diese \ac{ML} Funktionen sind die Grundlage für das Konzept, welches das Problem lösen könnte. Dazu werden, zusätzlich zu \ac{ML}-Nodes noch andere Produkte der Firma Elastic verwendet.

Ein weiteres Produkt nennt sich \ac{APM}\footnote{\url{https://www.elastic.co/de/apm}}, welches die Möglichkeit hat sowohl anwedungsspezifische Daten, als auch hardwarespezifische (oder containerspezifische) Metriken zu sammeln und direkt in einen entsprechenden ElasticSearch-Index zu speichern. Für das \ac{APM} gibt es Integrationen für alle wichtigen Programmiersprachen\footnote{\url{https://www.elastic.co/guide/en/apm/get-started/current/index.html}}. Diese Software liefert wichtige Informationen über den aktuellen Zustand eines Services und bietet auch gleichzeitig eine zentralisierte Sammelstellen für diese Metriken. 

Dies erfüllt die Punkte vier und fünf der Anforderung \vref{chap:Anforderungen}. Das initiale Aufsetzen der Infrastruktur benötigt allerdings durchaus produktspezifisches Know-How. Danach ist es aber ein sehr einfacher Prozess neue Services anzuschließen, da dies rein auf Serviceebene, also von den implementierenden Teams erledigt werden kann und unterstützt somit den dezentralen Ansatz einer Microservicearchitektur. Es fehlt allerdings noch die Auswertung und Aufbereitung der durch \ac{APM} gesammelten Daten. Dazu kann das Visualisierungstool von Elastic, \textbf{Kibana}\footnote{\url{https://www.elastic.co/de/kibana}}, verwendet werden. \\
Kibana nutzt die vorhandenen Indizes in einem ElasticSearch Cluster, um verschiedenste Operationen, meistens visualisierender Art, durchzuführen. Dort können auch eigene Visualisierungen konfiguriert werden, welche dem Endnutzer ermöglichen, eine für ihn optimale Informationslandschaft zu gestalten. Dies erfüllt das zweite definierte Kriterium aus \vref{chap:Anforderungen}, da es die durch \ac{APM} gesammelten Daten aufbereitet zu wertvollen Informationen, welche Hinweise geben auf den internen Zustand eines Services.

Die Kombination aus \ac{APM} und Kibana stellen also Tools dar, die einen Fokus auf die Observability haben. Das eigentliche Problem beinhaltet aber auch, dass ein Nutzer sehr schnell Wissen muss, um welchen Fehler es sich handelt und wie groß die Auswirkungen davon sind. Zusätzlich ist es wichtig, bereits während der Entwicklung eines Services zu wissen, in welcher Umgebung sich der Service befindet. Um diese Governanceaspekte in diesen Lösungsvorschalg zu integrieren kommen die bereits angesprochenen \ac{ML} Nodes ins Spiel. Diese bieten die Möglichkeit eine Analyse der Daten in einem Index durchzuführen. Ab dann kann festgestellt werden, ob ein System \enquote{normal} operiert oder nicht. Sollten nun Metrken aus \ac{APM} in dem Index gespeichert werden, welche Hinweise auf einen Fehler enthalten, so wird die Analyse dies erkennen und besteht die Möglichkeit des schnellen entdeckens des Fehlers. Gleichzeitig beinhaltet die Nutzung der \ac{ML} Funktionalität auch eineige Schwierigkeiten.

So ist es z.B. während der Analyse schwer zu unterscheiden, ob eine erkannte Anomlie wirklich ein Fehler ist, oder einfach nur ein neuer Service, der hinzugefügt wurde. Es ist auch nur schwer möglich die Metriken unterscheidlicher Services in einer einzelnen \ac{ML} Node auszuwerten, da durch unterschiedliche Hardwaredaten der verschiedene Services ein sehr breites Spektrum als \enquote{normal} angsehen wird. Es gilt also hierfür eine Lösung zu finden, welche nicht beinhaltet, dass für jeden neuen Service eine neue \ac{ML} Pipeline angelegt werden muss.

Die Idee dieses bestehenden Tools zu verwenden, um das Problem zu lösen ist prinzipiell nicht von der Hand zu weisen, da auch einige wesentliche Anforderungen aus \vref{chap:Anforderungen} erfüllt werden. Allerdings bringt es auch Schwierigkeiten mit, die es vor der Einführung und dauerhaften Nutzung dieser Tools zu lösen gilt.

\section{Konzept unter Nutzung einer Graphdatenbank}

Im ersten Abschnitt dieses Kapitles wurden bereits Grundlage im Bezug auf Graphen und deren Eingeschaften erläutert. Die Idee Graphen zu verwenden, um Abhängigkeiten und Verbindungen zwischen Elementen darzustellen ist nicht neu. Bereits \citeyear{Metayer1998} erläuterte \citeauthor{Metayer1998} in \citetitle{Metayer1998} einen Ansatz, wie man mithilfe formaler Sprachen die Softwarearchitektur in einem Graphen abbilden kann \autocite{Metayer1998}.

\begin{example}[Abhängigkeitsgraphen]
	Abhängigkeitsgraphen werden auch in Toolings für verschiedene Programmiersprachen verwendet. Ein Beispiel ist JavaScript. Diese ermöglichen es Dateien, verschiedenen Formats miteinenander zu kombinieren und in einer Datei, dem Bundle, zusammenzuführen. Dabei ist es wichtig, dass alle Dateien in der richtigen Reihenfolge in das Bundle integriert werden, um am Ende ein lauffähiges Programm zu erhalten. Um zu wissen, welche Dateien in welcher Reihenfolge eingefügt werden müssen, wird ein Abhängigkeitsgraph erstellt, an dem abgelesen werden kann, welche Datei benötigt wird, um eine andere valide Datei zu erhalten.
\end{example}

Das Konzept eines Abhängigkeitsgraphen ist auch die Grundlage für die Idee, die Abhängigkeiten zwischen Services über einen Graphen darzustellen. Für die Realisierung des Konzeptes kann eine beliebige Graphdatenbank gewählt werden. Dabei sollte aber darauf geachtet werden, dass es sich um eine \enquote{native} Graphdatenbank handelt. Das bedeutet, dass der primäre Anwedungsfall des \ac{DBMS} die Darstellung und Speicherung der Daten in einem Graphen ist. Andere \ac{DBMS}, wie z.B. Elastic oder MongoDb bieten auch die Möglichkeit Daten mithilfe von Graphen darzustellen und zu speichern. In diesen Datenbanken sind die Graphen nur unter zuhilfenahme einer großen Anzahl an Indizes realisierbar \autocite{JoyChao2016}. Diese \enquote{nicht-nativen} Graphen haben oftmals eine deutlich schlechtere Performance als ein \ac{DBMS}, welches einen nativen Graphen realisiert.\\
Für den oben beschriebenen Anwendungsfall sollte also ein \ac{DBMS} gewählt werden, welche eine native Implementierung eines Graphen besitzt.

\subsection{Das Konzept eines Microservicegraphen}

Wie bereits in \vref{exp:microserviceGraph} beschrieben, kann die Menge der Knoten in einem Graphen mit den Microservices innerhalb eines Unternehmens gleichgesetzt werden. Diese Knoten können innerhalb einer Graphdatenbank noch zusätzliche Eigenschaften erhalten. Im folgenden wird exemplarisch \textbf{Neo4j}\footnote{\url{https://neo4j.com/}} als konkretes \ac{DBMS} verwendet. Allerdings können alle spezifischen Konzepte auch auf andere Graphdatenbanken angewendet werden.

Die grundlegende Idee soll anhand eines sehr einfachen Graphen beschrieben werden. Dieser Graph $G$ ist definiert mit:
\begin{itemize}
	\item $V = \{\text{Service A, Service B}\}$ und
	\item $A = \{(\text{Service A},\text{Service B}), (\text{Service B}, \text{Service A})\}$
\end{itemize}

Diese Defition führt zu folgenden Graphen:

\begin{figure}[h]
	\centering
	\includegraphics[width=0.65\linewidth]{img/service_dependencies.png}
	\caption[Abbildung eines simplen Abhängigkeitsgraphen]{Visualisierung des Graphen\\Quelle: Eigen}
\end{figure}

Da es sich um einen gerichteten Graphen mit geoordneten Tupeln als Elemente der Kantenmenge handelt, kann die Richtung der Abhängigkeit erkannt werden. Zu lesen ist es folgendermaßen:

\begin{center}
	Service A benötigt den \texttt{/foo}-Endpunkt von Service B\\
	Service B benötigt den \texttt{/bar}-Endpunkt von Service A
\end{center}

In der mathematischen Darstellung alleine ist allerdings noch keine Information bzgl. der Abhängigkeit zu erknennen. In einem \ac{DBMS} wie Neo4j ist dies allerdings möglich, da es sich bei der vorhandenen Implementierung um einen sogenannten \textbf{property graph} handelt. Dieser Graph kann Schlüssel-Wert Paare sowohl an den Knoten (Nodes), als auch an den Kanten (Relationships) speichern \footnote{\url{https://neo4j.com/developer/graph-database\#property-graph}}.

\subsection{Mögliche Realiserungen des Konzepts}

Nun, da das unterliegende Datenmodell geklärt müssen weitere Aspekte des Konzepts erläutert werden, um die Anforderungen entsprechend zu erfüllen. Dazu werden nun verschiedene technische Möglichkeiten präsentiert, wie ein solches Tool in eine Microservicearchitektur integriert werden kann. Ein er dieser Aspekte ist der Aufbau des Graphs. Es wurde bereits in \vref{exp:microserviceGraph} geklärt, wie das Datenmodell aussehen kann. Nun sollen verschiedene Möglichkeiten vorgeschlagen werden, um den Graphen anhand der in einer Architektur vorhandenen Services und Abhängigkeiten aufzubauen.

\subsubsection*{Statischer Ansatz}
Wie bereits in der Definition eines Microservice festgehalten, ist es in der Pflicht des dafür zustädnigen Teams parallel zum Service auch eine \textbf{Service Defintion} bereitzustellen. Ein offener Standard zum beschreiben von REST Schnittstellen ist OpenAPI 3.0 \footnote{TODO: Quelle}. Innerhalb dieses Standards gibt es außerdem die Möglichkeit, weitere Metadaten zum beschreiben eines Services zu speichern. Um nun dem Graphen die benötigten Daten bereitzustellen, kann das für einen Service zuständige Team die Abhängigkeiten in ein speziell definiertes Metadatenfeld eintragen. Die zentrale Komponenten die dafür verantwortlicht ist den Graphen aufzubauen könnte dann auf Basis dieser Informationen einen die Architektur repräsenierenden Graphen konstruieren. Diese Methode bringt allerdings einige Probleme mit sich, welche die Nutzung eines solchen Tools erschweren würden:

\begin{enumerate}
	\item Manuelle Fehler beim eintrager der dependencies und man muss es immer aktualisieren
	\item Wie trägt man es überhaupt ein? URL's sind auch nicht immer gleicht, identifier? Dann brauch man ein krasses Konzept dafür
	\item Prozess ist generell langsam und nur mit Aktualisierung der SD kann eine Aktualisierung des Graphen erreicht werden. Das heißt, erst danach ist bekannt was sich verändert, somit wiederspricht es der eigentlichen Idee der Risikominimierung
\end{enumerate}

\section{Bewertung und Gegenüberstellung der Methoden}

\begin{itemize}
	\item Kurze Einführung in Graphdatenbanken, im speziellen Neo4j. Wieso passen die so gut? referenzieren auf Bilder und \enquote{Abhängigkeiten} Wie kann damit eine Lösung konstruiert werden?
	\begin{itemize}
		\item Statischer Ansatz $\Rightarrow$ von den Entwicklern definierte Abhängigkeiten werden in der Service-Definition angegeben. Der Graph kann aus diesen SD's erstellt werden. Hier gibt es Probleme: Manuelle Veranwtortlichkeit widerspricht eigentlicher Idee von Risikoeinschätzung, da ein neuer Fehler Mensch eingebaut wird.
		\item Automatischer Nutzungsbasierter, somit dynamischer Aufbau des Graphen. Prinzip ähnlich wie bei Prometheus (populäres Tool zum sammeln von Metriken). Konzept ähnlich wie Distributed Tracing. Dort werden alle Traces mit ihren Spans zusammengefasst und zentral ausgewertet. Kombination aus dieser Idee mit Prometheus-Ansatz sieht dann folgendermaßen aus:
		
		Jeder Service exposed einen \texttt{/traffic}-Endpoint der unstrukturierte Daten bzgl. der Netzwerkaktivität enthält. Diese können dann in einem Service der für den Aufbau des Graphen zuständig ist zu ebendiesem umgewandelt werden.
		\item Es kann zusätzlich überlegt werden, ob anstatt dieses \texttt{PULL}-Verfahrens eine Push Variante gewählt wird, welche ähnlich wie \texttt{fluentd} als Sidecar in einer Containererisierten Umgebung läuft. Die könnte dann periodisch die Netzwerkdaten pushen, wenn sie Zugriff darauf hat.
	\end{itemize}
	\item Es kann überlegt werden welche Metadaten zusätzlich im Rahmen dieses Graphen eine sinnvolle Ergänzugn bieten würden, sodass ein weiterer Mehrwert geschaffen werden kann. (Ist das noch im Rahmen der Arbeit? Kommt das eher in den Ausbilck mit ein paar Ideen?)
	\item Wie können jetzt die Sachen in dem coolen Graphen genutzt werden?
	\begin{itemize}
		\item Kurze \texttt{CYPHER-QUERIES} Aufschreiben:
		\begin{itemize}
			\item Wie finde ich affectete services raus
			\item was passiert wenn ein Service X ausfällt
			\item Was ist die Zentralste Komponente in meinem Unternehmen
			\item usw.
		\end{itemize}
	\end{itemize}
\end{itemize}

\chapter{Bewertung und Einschätzung der Arbeit, sowie Ausbilck auf künfitge Arbeiten}
%	Literaturverzeichnis
\clearpage
\ihead{}
\printbibliography[title=Literaturverzeichnis]
\cleardoublepage

% Der Anhang beginnt hier - jedes Kapitel wird alphabetisch aufgezählt. (Anhang A, B usw.)
% \appendix
% \ihead{\appendixname~\thechapter} % Neue Header-Definition

% Ehrenwörtliche Erklärung ewerkl.tex einziehen
\input{ewerkl.tex}


\end{document}
